---
title: 变量作用域
description: 了解变量作用域相关知识
img: https://images.unsplash.com/photo-1614213671535-a82e778bc06a?ixid=MnwxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwyMnx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=60
alt: 变量作用域
tags: 
  - javascript
---
## 作用域简介（scope）

作用域是编程领域的通用概念，并不是 JS 特有的，我们先来看一些基本概念：

**variable**：变量，值的符号名称。变量的名字叫标识符（identifier）。如 let x = 1; 中 x 就是变量。

**value**：值，即数据，比如字符串、数值、函数等。

**name binding**：变量和值所建立的联系，如 let x = 1;。

**scope**：作用域，值代码中 name binding 的有效范围。比如在这个区块的代码中，变量 x 的值是 1，在另外一个区块的代码中，变量 x 的值是 2。

## 作用域分类

作用域分为静态作用域（static scope）和动态作用域（dynamic scope），静态作用域又叫 lexical scope ，中文翻译为词法作用域。我们先来看两个对应的示例：

### 作用域示例（C）：静态作用域

```c
#include<stdio.h>
int x = 10;
int f()
{
  return x;
}
int g()
{
  int x = 20;
  return f();
}
int main()
{
  printf("%d",g());
  printf("\n");
  return 0;
}
```

这是一段 C 语言代码，C 语言使用的是静态作用域，代码先声明了一个整型变量 x，它的值是 10，然后声明了两个函数 f() 和 g()，在执行 main() 函数的时候，调用了函数 g()，函数 g() 声明了一个变量 x，它的值是 20，然后它调用了函数 f()，并返回函数的调用结果，函数 f() 返回了 x 的值，它返回的是最开始声明的那个 x 的值，也就是 10，并不是在函数 g() 中声明的那个 x。

### 作用域示例（Perl）：动态作用域

```perl
$x = 10;
sub f
{
  return $x;
}
sub g
{
  local $x = 20;
  return f();
}
print g()."\n";
```

这是一段 Perl 语言代码，Perl 既可以使用静态作用域，也可以使用动态作用域。这段代码它使用的是动态作用域，代码的逻辑和之前的 C 语言是一抹一样的。但在函数 f 中返回的是在函数 g 中定义的 \$x，即最终返回的是 20。

**在静态作用域中，如果函数中的变量，没有在该函数中定义（即它不熟函数的局部变量，也不是形参），就去*定义*该函数的地方查找。**

**在动态作用域中，如果函数中的变量，没有在该函数中定义，就去*调用*该函数的地方查找。**

注意，一个是*定义该函数*，一个是*调用该函数*。

**静态作用域，也叫词法作用域，代码写完后，变量的作用域就已确定不变。**

不变的另一个名字就叫静态，所以叫静态作用域。

**动态作用域，代码写完后，变量的作用域还无法确定，它和调用它所在的函数有关。**

这么听起来，使用动态动态作用域的代码，复用程度更高，因为变量在不同的调用中有不同的含义和值，但复杂度也增加了。

静态作用域在编程语言中占了统治地位，比如 C、C++、C#、JAVA、Go 语言都使用了静态作用域，这也比较好理解，因为静态作用域更方便调试，也更好理解。

JavaScript 也使用静态作用域，下面我们把前面的代码翻译成 JavaScript 的代码：

### 作用域示例（JavaScript）：静态作用域

```js
let x = 10;
function f() {
  return x;
}
function g() {
  let x = 20;
  return f();
}
console.log(g())
```

最终输出的结果是 10。

## 块级作用域（block scope）

**块级作用域是指变量在指定块的作用域外部无法被访问，它位于一对花括号中。语法和 var 语句一样，只是它使用 let 或者 const 来声明。**

比如下面这段代码：

```js
let y = 1;
if(true) {
  var x = 2;
  let y = 2;
}
console.log(x); // 2
console.log(y); // 1
```

最后输出的 x 的值是 2，他在 if() 语句块外面也能访问到。输出的 y 的值是 1，if() 语句块中的声明不会影响到语句块外面的值。

### 禁止重复声明

**如果变量在语句块中已经有定义，则无法再使用 let 或者 const 进行重复声明，会报语法错误。**

比如下面这段代码：

```js
var x = 1;
let x = 2;
// Uncaught SyntaxError: Identifier 'x' has already been declared
```

注意，这只限制在同个块中，如果是在不同块中是没有问题的。

比如下面这段代码就没有什么问题：

```js
var x = 1;
if(x) {
  let x = 1;
}
```

大家看到这里可能会有疑问，那到底在实际工作中应该使用 var 还是使用 let，还是两者都使用？首先，两者混用是毫无道理的，但是这在实际代码中经常出现。这一方面就是粗心大意导致的，另外一方面可能是只重构了部分代码。但是，var 和 let 混用是不能被原谅的行为。本文最后有一个最佳实践，会再来讨论该用什么方式来声明变量。

### const 声明

**使用 const 声明的原始类型，是常量，之后不能更改，不然会报类型错误。使用 const 声明的对象类型变量，变量本身无法赋值为其它类型，但它的属性可以修改。**

比如下面这两段代码：

```js
const x = 1; // const x = {};
x = 2; // Uncaught TypeError: Assignment to constant variable.
```

```js
const x = {};
x.age = 23;
```

第一段代码使用 const 声明了变量之后，不管是 1 还是空对象，之后再想把 x 更改为 2，是不可以的。第二段代码使用 const 声明 x 为一个空对象，之后可以给它添加属性，是没有任何问题。那有没有办法让一个对象的属性也无法改变呢？我们可以使用 Object.freeze() 方法，比如下面这段代码：

```js
// 'use strict'
const obj = Object.freeze({});
obj.prop = 123;
```

使用 Object.freeze() 方法，参数是一个空对象，创建一个变量 obj，之后再修改 obj 的话，默认是没有效果的。如果是在严格模式下，还汇报 TypeError 错误。

## 暂时性死区（temporal dead zone, TDZ）

很对书籍和文章都会说，const 和 let 声明的变量不会提升，我们来分析一下下面这段代码：

```js
var x = 1;
if(true) {
  // ********* 暂时性死区 **********
  console.log(x); // ReferenceError: x is not defined
  // ********* 暂时性死区 **********
  let x = 2;
}
```

如果 if 语句块中的用 let 声明的变量 x 没有提升，那在它前面输出 x 时，应该找到 if 语句块外面那个全局变量 x 才对。但事实上它会报一个 ReferenceError 的错误，说 x 没有被定义。所以说，x 没有提升，这是不大准确的。提升的行为我们很好理解，但大家想过这用代码来实现是如何做到的吗？其实提升就在引擎在运行语句块前，会把块中的所有变量提前放到内存中去，上面这段代码之所以报了错，是因为引擎已经提前知道了下面有使用 let 声明的 x 了，所以提升的行为是存在的。这种情况要报错，这是 ES 规范规定的。

**在使用 let 声明的变量 x 语句，到块的顶部这段区域，称为变量 x 的暂时性死区，在这个区块中的所有代码不能访问 x。**

## 循环语句中的块级绑定

下面我们来学习一下，循环语句中的块级绑定。我们先来看这个循环语句：

```js
for (var i = 0; i < 3; i++) {
  // do something
}
console.log(i); // 3
```

很多初学者都会遇到这个问题，就是循环结束后，还可以访问到变量 i 的值，它的值是 3。一般来说，for() 循环中的这个迭代变量 i，在 for() 语句之外是不会用到的。我们可以使用 let 来声明变量 i，这样在 for() 语句之外就无法访问到变量 i 了：

```js
for (let i = 0; i < 3; i++) {
  // do something
}
console.log(i); // Uncaught ReferenceError: i is not defined
```

## 循环语句中的函数

我们再来看一个很常见的问题，这个问题也困扰了相当多的初学者。比如下面这段代码：

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => alert(i));
}
```

我们在循环中调用了 setTimeout() 计时器方法，让它输出 i。直觉来看它应该输出 0， 1， 2，但实际上它输出的是三个 3。因为等到 setTimeout() 中的函数被调用时，for() 循环已经运行结束了，变量的 i 值已经是 3 了，所以输出的是三个 3。这里的计时器在实际工作中很可能是一个　 ajax 异步调用，原理是一样的。很多开发人员，会使用一个立即执行函数表达式来解决这个问题，关于什么是立即执行函数表达式，会在函数进阶文章中再来介绍。总之，这个函数是可以立即执行的：

```js
for (var i = 0; i < 3; i++) {
  (function (value) {
    setTimeout(() => alert(value));
  })(i);
}
```

这在 ES6 之前也确实没有什么好的办法，ES 规范的制定者们也考虑到了这个问题，规范明确规定：可以使用 let 来解决这个问题。只要把 var 换成 let 就可以了：

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => alert(i));
}
```

在使用 let 声明变量 i 后，在每次迭代中，都会创建一个新的同名变量，并对其进行初始化，效果是和使用立即执行表达式是一样的，但它的写法更简单。这种方法在 for(in) 和 for(of) 循环中是同样适用的：

```js
let obj = {x: 1, y: 2, z: 3};
for (let k in obj) {
  setTimeout(() => {
    alert(obj[k]);
  })
}
```

## 循环语句中的常量声明

那是不是可以使用 const 来声明循环变量 i 呢？在 for() 循环中，可以在初始化的时候使用 const，但在运行 i++ 语句时会报错，因为这是在尝试修改它的值，所以这个循环只能运行一次：

```js
for (const i = 0; i < 3; i++) { // Uncaught TypeError: Assignment to constant variable.
  setTimeout(() => alert(i));
}
```

在 for(in) 和 for(of) 语句中可以使用 const，效果和使用 let 是一样的：

```js
let obj = {x: 1, y: 2, z: 3};
for (const k in obj) {
  setTimeout(() => alert(obj[k]));
}
```

## 全局块级绑定

**使用不同的方式声明变量，对全局变量也有不同的影响。使用 var 声明的变量会成为全局对象的属性，意味着可能会无意覆盖已存在的全局属性。而用 let 和 const 声明的全局变量，不会添加到全局对象上。**

比如这两段代码：

```js
var JSON = 'json';
alert(window.JSON); // 'json'
```

```js
let JSON = 'json';
alert(window.JSON); // '[object Object]'
```

我们先用 var 声明了一个变量 JSON，那它会覆盖全局对象上的属性 JSON，它是一个内置的属性。如果用 let 声明这个变量，就不会有这个问题了。

## 最佳实践

那到底使用哪种方式声明变量更合适呢？我们应该优先使用 const 来声明变量，如果确定变量之后会被更改的话，再使用 let。大部分变量在初始化之后就应该保持不变，因为预期外的改动很容易出现 BUG。我们要避免使用 var。当然这一切的前提是软件的运行环境要支持 ES6，不然都是空谈。

1. **优先使用 const。**
2. **如果之后会改变，则使用 let。**
3. **避免使用 var。**

## 作用域链（scope chain）

这是一段示例代码：

```js
var x = 5;
function f() {
  var y = 10;
  console.log(x, y);
  function f_1() {
    var z = 15;
    console.log(x, y, z);
  }
  f_1();
}
f();
```

我们来看一下 `console.log(x, y, z);` 这段代码：。

![](/img/变量作用域_0.png)

在执行这条语句时，它会在函数 f_1() 的作用域中依次查找变量 x，y 的值，在 f_1() 中没有找到 x，就到它的上一层作用域——也就是函数 f() 的作用域中去查找。在函数 f() 中也没有找到 x，就再到它的上一层作用域，这里呢就是全局作用域中去查找了。结果是找到了。接下来是查找 y，z，过程和查找 x 是一样的。在这个过程中，只要一个变量没有找到定义，就会报错。在查找变量的时候，它是一层一层往上查找的，先是函数 f_1()，然后是函数 f()，最后是全局作用域。全局作用域就没有外层作用域了。大家看这个红色的箭头，它的组成很像一条链，所以这些作用域的组成就叫作用域链。是不是很形象。函数 f_1() 的作用域链包括：它自身的作用域 + f() 的作用域 + 全局作用域。

**在 JS 的最顶层代码中（也就是不包含在函数作用域，或者是块级作用域中的代码），作用域链由一个全局对象组成，这个全局对象可以通过 this 访问到。**

**在没有被嵌套的的作用域中（比如在一个函数中，或者是在一对花括号组成的块级作用域中），作用域链上有两个对象，第一个是包含局部变量的对象（如果实在函数中，这个对象还包括了函数的参数，以及 Arguments 对象），第二个是全局对象。前者无法被 JS 代码访问到，是不可见的内部实现。**

**在被嵌套的作用域中，作用域链上最少有三个对象（具体有几个对象，要看它被嵌套的层数了）。**

## 作用域链延长

**有些语句可以在作用域链的前端临时增加一个变量对象（variable object），该变量对象在代码执行完后被移除。有两种情况：**

1. **try-catch 语句中的 catch 块**
2. **with 语句**

### try-catch

**catch 语句会创建一个新的变量对象，它的值是被抛出的错误对象。在代码进入 catch 语句时，这个错误对象被添加到作用域链的顶端，当执行完 catch 语句时，该对象不再可用。**

这在 JS 中是一个特殊的情况，它不能被称之为块级作用域，比如下面这段代码：

```js
let e = 5;
try{
  e = y;
} catch (e) {
  console.dir(e);
}
// ReferenceError: y is not defined
//     at <anonymous>:3:3
// message: "y is not defined"
// stack: "ReferenceError: y is not defined at <anonymous>:3:3"
// __proto__: Error
```

在 try 语句中引用了一个没有被声明的变量 y，它会报错，进入到 catch 语句块中，此时会在当前的作用域链顶端添加一个错误对象 e，我们可以把它输出出来，它有 message 和 stack 这两个属性。

### with

**with 可将某个对象添加到作用域链的顶端，然后执行 with 语句块中的代码，执行完后会把作用域链回复到原来的状态。**

比如下面这段代码：

```js
function f(foo, x, y) {
  with(foo) {
    console.log(x, y); // 1, 3
  }
  console.log(x, y); // 2, 3
}
f({x: 1}, 2, 3);
```

在执行 f 函数的时候，里面有一条 with 语句，它会把 foo 对象添加到作用域链的顶端，在语句块中输出 x 和 y 的时候，首先它会在 foo 对象上查找有没有 x 和 y 属性，对象 Foo 正好有一个 x 属性，所以 x 的值是 1，但 foo 没有 y 属性，所以会沿着作用域链往上查找，此时查找的是参数 y，在调用 f 的时候传入的是 3，所以这里输出的 y 也是 3。执行完 with 语句后，作用域链会恢复到原来的状态，此时再输出 x 和 y 的值，它们都是调用函数 f 时传入的，所以它们的值分别是 2 和 3。因为 with 语句块中的变量只有在运行时才能确定，引擎无法提前进行优化，所以在严格模式下禁止使用 with 语句。可以换一种写法，就是用一个局部变量先把对象保存起来，再在语句块中访问这个变量的相应属性就可以了。

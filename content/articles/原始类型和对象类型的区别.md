---
title: 原始类型和对象类型的区别
description: 学习 JavaScript 原始类型和对象类型
img: https://cdn.pixabay.com/photo/2017/10/31/19/05/web-design-2906159_1280.jpg
alt: 原始类型和对象类型的区别
tags: 
  - javascript
---
## JavaScript 的数据类型

在 JS 中，数据类型分为原始类型和对象类型。
![](/img/原始类型和对象类型的区别_0.png)

## 原始类型

原始类型的值无法更改。比如我们想更改数值和布尔，这本身就说不通。但对于字符串来说，它们看起来是由字符组成的数组，所以想当然的会期望通过指定索引来修改字符串中的字符，实际上这是做不到的。我们来看一下这段代码：

```js
// 'use strict';
var a = 'abc';
a[1] = 'a';
alert(a); // abc
```

想把字符串中的第二个字符改为 a ，但实际输出还是 abc 。如果是严格模式，还会报语法错误。大家以后会感觉到，严格模式很多时候就是用来阻止这种看似正常，实际却是有问题的行为的。

字符串中的所有方法返回的都是一个新的字符串，并不会修改原来的字符串。我们来看一下这段代码：

```js
var s = 'ABC';
s.toLowerCase('');
alert(s); // 'ABC'
```

比如我们声明了一个变量 ABC ，它是大写的。然后我们调用 toLowerCase 把它转成小写，最后输出的 s 还是大写的 ABC ，它并不会修改原来字符串的值。

### 原始类型：相等比较

比较原始类型是否相等，是比较它们的值。

原始类型的比较是值的比较，只有它们的值相等，它们才相等。

```js
var n1 = 123;
var n2 = Number(123);
console.log(n1 === n2); // true

var s1 = 'abc';
var s2 = String('ab c');
console.log(s1 === s2); // false
```

上面这段代码，变量 n1 和 n2 它们的值都是 123 ，所以它们是相等的。如果是比较两个字符串是否相等，当且仅当它们的长度相等，并且每个索引的字符都相等时，它们才相等。变量 s1 的值是 abc ，s2 的值是 ab(空格)c ，所以它们是不相等的。

## 对象类型

对象类型的值是可以修改的。

比如下面这段代码：

```js
var o = {x:1};
o.x = 2;
o.y = 3;
console.log(o); // {x: 2, y: 3}
delete o.x;
console.log(o); // {y: 3}
```

我们定义了一个对象 o ，它有一个属性 x ，它的值是 1 。我们可以修改 x 的值，把它改成 2 ，也可以添加另外的属性比如说 y ，我们也可以把 x 属性删除。

比如数组，我们可以通过索引来修改相应位置的值：

```js
var a = [1, 2, 3];
a[1] = 4;
console.log(a); // [1, 4, 3]
```

### 对象类型：相等比较

比较对象是否相等，不是比较它们的值。

对象类型的比较并不是按值比较的，即使两个对象完全一样，或者是元素完全一样的数组，它们都是不相等的。

记住，没有两个对象是相等的。

比如，我们来看一下这段代码：

```js
var o1 = {x: 1}, o2 = {x: 1};
var a1 = [1, 2, 3], a2 = [1, 2, 3];
console.log(o1 === o2); // false
console.log(a1 === a2); // false
```

o1 是一个对象，它有一个属性 x ，它的值是 1 ，o2 也是一样的。比如还有两个变量 a1 和 a2 这两个数组，它们的元素都是 1 2 3 。但是，o1 o2 不相等，a1 a2 也不相等。

那对象类型是如何比较相等的呢？下面我们就来讨论这个问题。

### 对象类型：另一个名字

对象类型又叫引用类型（reference type），当给一个变量赋值为对象时，该变量保存的是该对象在内存中的地址。

对象的比较是在比较引用地址：当且仅当它们引用的是同一个对象时，（意味着它们的值都是一样的，也就是都是这个对象的内存地址）它们才相等。

比如下面这段代码：

```js
var o1 = {x: 1};
var o2 = o1;
o2.y = 2;
console.log(o1.y); // 2
console.log(o1 === o2); // true
```

将只有一个 x 属性的对象赋值给变量 o1 ，那只是把这个对象在内存中的地址赋给了这个变量，此时再将 o1 赋值给变量 o2 ，o2 的值也是 o1 所引用对象的内存地址，它们俩指向的是同一个对象。此时，如果修改了 o2 ，其实就是在修改内存中的对象({x: 1})，因为 o1 也指向的是这个对象，所以 o1.y 的值也是 2.

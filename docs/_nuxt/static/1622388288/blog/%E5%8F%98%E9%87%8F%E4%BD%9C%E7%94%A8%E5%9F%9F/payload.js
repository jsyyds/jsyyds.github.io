__NUXT_JSONP__("/blog/%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF){return {data:[{article:{slug:aI,description:"了解变量作用域相关知识",title:aI,img:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1614213671535-a82e778bc06a?ixid=MnwxMjA3fDB8MHxlZGl0b3JpYWwtZmVlZHwyMnx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=800&q=80",alt:aI,tags:[aJ],toc:[{id:au,depth:Q,text:au},{id:av,depth:Q,text:av},{id:aT,depth:aa,text:aU},{id:aV,depth:aa,text:aW},{id:aX,depth:aa,text:aY},{id:aZ,depth:Q,text:a_},{id:aw,depth:aa,text:aw},{id:a$,depth:aa,text:ba},{id:bb,depth:Q,text:bc},{id:ax,depth:Q,text:ax},{id:ay,depth:Q,text:ay},{id:az,depth:Q,text:az},{id:aA,depth:Q,text:aA},{id:aB,depth:Q,text:aB},{id:bd,depth:Q,text:be},{id:aC,depth:Q,text:aC},{id:aD,depth:aa,text:aD},{id:ao,depth:aa,text:ao}],body:{type:"root",children:[{type:b,tag:R,props:{id:au},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%AE%80%E4%BB%8B%EF%BC%88scope%EF%BC%89",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:au}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"作用域是编程领域的通用概念，并不是 JS 特有的，我们先来看一些基本概念："}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:af}]},{type:a,value:"：变量，值的符号名称。变量的名字叫标识符（identifier）。如 let x = 1; 中 x 就是变量。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:aK}]},{type:a,value:"：值，即数据，比如字符串、数值、函数等。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"name binding"}]},{type:a,value:"：变量和值所建立的联系，如 let x = 1;。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"scope"}]},{type:a,value:"：作用域，值代码中 name binding 的有效范围。比如在这个区块的代码中，变量 x 的值是 1，在另外一个区块的代码中，变量 x 的值是 2。"}]},{type:a,value:f},{type:b,tag:R,props:{id:av},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86%E7%B1%BB",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:av}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"作用域分为静态作用域（static scope）和动态作用域（dynamic scope），静态作用域又叫 lexical scope ，中文翻译为词法作用域。我们先来看两个对应的示例："}]},{type:a,value:f},{type:b,tag:ab,props:{id:aT},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%A4%BA%E4%BE%8B%EF%BC%88c%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:aU}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,"language-c"]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,"macro","property"]},children:[{type:b,tag:c,props:{className:[d,"directive-hash"]},children:[{type:a,value:"#"}]},{type:b,tag:c,props:{className:[d,"directive",i]},children:[{type:a,value:"include"}]},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"\u003Cstdio.h\u003E"}]}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ap}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aE}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ap}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ac}]},{type:a,value:aL},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ap}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ap}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ac}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ap}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:"main"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:bf}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"\"%d\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:bf}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:bg}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ac}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"这是一段 C 语言代码，C 语言使用的是静态作用域，代码先声明了一个整型变量 x，它的值是 10，然后声明了两个函数 f() 和 g()，在执行 main() 函数的时候，调用了函数 g()，函数 g() 声明了一个变量 x，它的值是 20，然后它调用了函数 f()，并返回函数的调用结果，函数 f() 返回了 x 的值，它返回的是最开始声明的那个 x 的值，也就是 10，并不是在函数 g() 中声明的那个 x。"}]},{type:a,value:f},{type:b,tag:ab,props:{id:aV},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%A4%BA%E4%BE%8B%EF%BC%88perl%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:aW}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,"language-perl"]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,af]},children:[{type:a,value:aN}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aE}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,n]},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:bh}]},{type:a,value:bi}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ac}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,af]},children:[{type:a,value:aN}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,n]},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:bh}]},{type:a,value:bj}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"local"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,af]},children:[{type:a,value:aN}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ac}]},{type:a,value:bi},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"print"}]},{type:a,value:bj},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:bg}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"这是一段 Perl 语言代码，Perl 既可以使用静态作用域，也可以使用动态作用域。这段代码它使用的是动态作用域，代码的逻辑和之前的 C 语言是一抹一样的。但在函数 f 中返回的是在函数 g 中定义的 $x，即最终返回的是 20。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"在静态作用域中，如果函数中的变量，没有在该函数中定义（即它不熟函数的局部变量，也不是形参），就去"},{type:b,tag:aG,props:{},children:[{type:a,value:"定义"}]},{type:a,value:bk}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"在动态作用域中，如果函数中的变量，没有在该函数中定义，就去"},{type:b,tag:aG,props:{},children:[{type:a,value:"调用"}]},{type:a,value:bk}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"注意，一个是"},{type:b,tag:aG,props:{},children:[{type:a,value:"定义该函数"}]},{type:a,value:"，一个是"},{type:b,tag:aG,props:{},children:[{type:a,value:"调用该函数"}]},{type:a,value:"。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"静态作用域，也叫词法作用域，代码写完后，变量的作用域就已确定不变。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"不变的另一个名字就叫静态，所以叫静态作用域。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"动态作用域，代码写完后，变量的作用域还无法确定，它和调用它所在的函数有关。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"这么听起来，使用动态动态作用域的代码，复用程度更高，因为变量在不同的调用中有不同的含义和值，但复杂度也增加了。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"静态作用域在编程语言中占了统治地位，比如 C、C++、C#、JAVA、Go 语言都使用了静态作用域，这也比较好理解，因为静态作用域更方便调试，也更好理解。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"JavaScript 也使用静态作用域，下面我们把前面的代码翻译成 JavaScript 的代码："}]},{type:a,value:f},{type:b,tag:ab,props:{id:aX},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%A4%BA%E4%BE%8B%EF%BC%88javascript%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:aY}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aE}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:ac}]},{type:a,value:aL},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aM}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:ac}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:aF}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"最终输出的结果是 10。"}]},{type:a,value:f},{type:b,tag:R,props:{id:aZ},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88block-scope%EF%BC%89",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:a_}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"块级作用域是指变量在指定块的作用域外部无法被访问，它位于一对花括号中。语法和 var 语句一样，只是它使用 let 或者 const 来声明。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:aO}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:aP},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:aQ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,bl]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:aP},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F 2"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:"y"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F 1"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"最后输出的 x 的值是 2，他在 if() 语句块外面也能访问到。输出的 y 的值是 1，if() 语句块中的声明不会影响到语句块外面的值。"}]},{type:a,value:f},{type:b,tag:ab,props:{id:aw},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E7%A6%81%E6%AD%A2%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:aw}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"如果变量在语句块中已经有定义，则无法再使用 let 或者 const 进行重复声明，会报语法错误。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:aO}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F Uncaught SyntaxError: Identifier 'x' has already been declared"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"注意，这只限制在同个块中，如果是在不同块中是没有问题的。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"比如下面这段代码就没有什么问题："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:aQ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"大家看到这里可能会有疑问，那到底在实际工作中应该使用 var 还是使用 let，还是两者都使用？首先，两者混用是毫无道理的，但是这在实际代码中经常出现。这一方面就是粗心大意导致的，另外一方面可能是只重构了部分代码。但是，var 和 let 混用是不能被原谅的行为。本文最后有一个最佳实践，会再来讨论该用什么方式来声明变量。"}]},{type:a,value:f},{type:b,tag:ab,props:{id:a$},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#const-%E5%A3%B0%E6%98%8E",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:ba}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"使用 const 声明的原始类型，是常量，之后不能更改，不然会报类型错误。使用 const 声明的对象类型变量，变量本身无法赋值为其它类型，但它的属性可以修改。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"比如下面这两段代码："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:aq}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F const x = {};"}]},{type:a,value:"\nx "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:bm}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:aq}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:"\nx"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,N]},children:[{type:a,value:"age"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"23"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"第一段代码使用 const 声明了变量之后，不管是 1 还是空对象，之后再想把 x 更改为 2，是不可以的。第二段代码使用 const 声明 x 为一个空对象，之后可以给它添加属性，是没有任何问题。那有没有办法让一个对象的属性也无法改变呢？我们可以使用 Object.freeze() 方法，比如下面这段代码："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F 'use strict'"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:aq}]},{type:a,value:aR},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,ar,I]},children:[{type:a,value:"Object"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:"freeze"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:"\nobj"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,N]},children:[{type:a,value:"prop"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"123"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"使用 Object.freeze() 方法，参数是一个空对象，创建一个变量 obj，之后再修改 obj 的话，默认是没有效果的。如果是在严格模式下，还汇报 TypeError 错误。"}]},{type:a,value:f},{type:b,tag:R,props:{id:bb},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%EF%BC%88temporal-dead-zone-tdz%EF%BC%89",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:bc}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"很对书籍和文章都会说，const 和 let 声明的变量不会提升，我们来分析一下下面这段代码："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:aQ}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,bl]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:bn}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F ReferenceError: x is not defined"}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:bn}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"如果 if 语句块中的用 let 声明的变量 x 没有提升，那在它前面输出 x 时，应该找到 if 语句块外面那个全局变量 x 才对。但事实上它会报一个 ReferenceError 的错误，说 x 没有被定义。所以说，x 没有提升，这是不大准确的。提升的行为我们很好理解，但大家想过这用代码来实现是如何做到的吗？其实提升就在引擎在运行语句块前，会把块中的所有变量提前放到内存中去，上面这段代码之所以报了错，是因为引擎已经提前知道了下面有使用 let 声明的 x 了，所以提升的行为是存在的。这种情况要报错，这是 ES 规范规定的。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"在使用 let 声明的变量 x 语句，到块的顶部这段区域，称为变量 x 的暂时性死区，在这个区块中的所有代码不能访问 x。"}]}]},{type:a,value:f},{type:b,tag:R,props:{id:ax},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:ax}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"下面我们来学习一下，循环语句中的块级绑定。我们先来看这个循环语句："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:Z}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:bo}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F 3"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"很多初学者都会遇到这个问题，就是循环结束后，还可以访问到变量 i 的值，它的值是 3。一般来说，for() 循环中的这个迭代变量 i，在 for() 语句之外是不会用到的。我们可以使用 let 来声明变量 i，这样在 for() 语句之外就无法访问到变量 i 了："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:Z}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:bo}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F Uncaught ReferenceError: i is not defined"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:R,props:{id:ay},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:ay}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"我们再来看一个很常见的问题，这个问题也困扰了相当多的初学者。比如下面这段代码："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:Z}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,am,l]},children:[{type:a,value:an}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"我们在循环中调用了 setTimeout() 计时器方法，让它输出 i。直觉来看它应该输出 0， 1， 2，但实际上它输出的是三个 3。因为等到 setTimeout() 中的函数被调用时，for() 循环已经运行结束了，变量的 i 值已经是 3 了，所以输出的是三个 3。这里的计时器在实际工作中很可能是一个　 ajax 异步调用，原理是一样的。很多开发人员，会使用一个立即执行函数表达式来解决这个问题，关于什么是立即执行函数表达式，会在函数进阶文章中再来介绍。总之，这个函数是可以立即执行的："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:Z}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,bp]},children:[{type:a,value:aK}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,am,l]},children:[{type:a,value:an}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:aK},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"这在 ES6 之前也确实没有什么好的办法，ES 规范的制定者们也考虑到了这个问题，规范明确规定：可以使用 let 来解决这个问题。只要把 var 换成 let 就可以了："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:Z}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,am,l]},children:[{type:a,value:an}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"在使用 let 声明变量 i 后，在每次迭代中，都会创建一个新的同名变量，并对其进行初始化，效果是和使用立即执行表达式是一样的，但它的写法更简单。这种方法在 for(in) 和 for(of) 循环中是同样适用的："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:aR},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ae}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ae}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:aS},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ae}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:Z}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:bq},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:br}]},{type:a,value:bs},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,am,l]},children:[{type:a,value:an}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bt},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bu}]},{type:a,value:bv},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bw}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:R,props:{id:az},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:az}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"那是不是可以使用 const 来声明循环变量 i 呢？在 for() 循环中，可以在初始化的时候使用 const，但在运行 i++ 语句时会报错，因为这是在尝试修改它的值，所以这个循环只能运行一次："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:Z}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:aq}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:ad}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ah}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:ai},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:bm}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,am,l]},children:[{type:a,value:an}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"在 for(in) 和 for(of) 语句中可以使用 const，效果和使用 let 是一样的："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:aR},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ae}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ae}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:aS},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ae}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:Z}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:aq}]},{type:a,value:bq},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:br}]},{type:a,value:bs},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:al}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,am,l]},children:[{type:a,value:an}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bt},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bu}]},{type:a,value:bv},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bw}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:R,props:{id:aA},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E5%85%A8%E5%B1%80%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:aA}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"使用不同的方式声明变量，对全局变量也有不同的影响。使用 var 声明的变量会成为全局对象的属性，意味着可能会无意覆盖已存在的全局属性。而用 let 和 const 声明的全局变量，不会添加到全局对象上。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"比如这两段代码："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,ar,I]},children:[{type:a,value:aH}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:bx}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,by,af]},children:[{type:a,value:bz}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,ar,I]},children:[{type:a,value:aH}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F 'json'"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,ar,I]},children:[{type:a,value:aH}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:bx}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,by,af]},children:[{type:a,value:bz}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,ar,I]},children:[{type:a,value:aH}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F '[object Object]'"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"我们先用 var 声明了一个变量 JSON，那它会覆盖全局对象上的属性 JSON，它是一个内置的属性。如果用 let 声明这个变量，就不会有这个问题了。"}]},{type:a,value:f},{type:b,tag:R,props:{id:aB},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:aB}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"那到底使用哪种方式声明变量更合适呢？我们应该优先使用 const 来声明变量，如果确定变量之后会被更改的话，再使用 let。大部分变量在初始化之后就应该保持不变，因为预期外的改动很容易出现 BUG。我们要避免使用 var。当然这一切的前提是软件的运行环境要支持 ES6，不然都是空谈。"}]},{type:a,value:f},{type:b,tag:bA,props:{},children:[{type:a,value:f},{type:b,tag:at,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"优先使用 const。"}]}]},{type:a,value:f},{type:b,tag:at,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"如果之后会改变，则使用 let。"}]}]},{type:a,value:f},{type:b,tag:at,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"避免使用 var。"}]}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:R,props:{id:bd},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%88scope-chain%EF%BC%89",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:be}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"这是一段示例代码："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:K},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:bB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:aP},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aE}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:bC}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:S}]},{type:a,value:" z "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"15"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:aS},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:bC}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"我们来看一下 "},{type:b,tag:u,props:{},children:[{type:a,value:"console.log(x, y, z);"}]},{type:a,value:" 这段代码：。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:"img",props:{alt:"",src:"\u002Fimg\u002F%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F_0.png"},children:[]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"在执行这条语句时，它会在函数 f_1() 的作用域中依次查找变量 x，y 的值，在 f_1() 中没有找到 x，就到它的上一层作用域——也就是函数 f() 的作用域中去查找。在函数 f() 中也没有找到 x，就再到它的上一层作用域，这里呢就是全局作用域中去查找了。结果是找到了。接下来是查找 y，z，过程和查找 x 是一样的。在这个过程中，只要一个变量没有找到定义，就会报错。在查找变量的时候，它是一层一层往上查找的，先是函数 f_1()，然后是函数 f()，最后是全局作用域。全局作用域就没有外层作用域了。大家看这个红色的箭头，它的组成很像一条链，所以这些作用域的组成就叫作用域链。是不是很形象。函数 f_1() 的作用域链包括：它自身的作用域 + f() 的作用域 + 全局作用域。"}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"在 JS 的最顶层代码中（也就是不包含在函数作用域，或者是块级作用域中的代码），作用域链由一个全局对象组成，这个全局对象可以通过 this 访问到。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"在没有被嵌套的的作用域中（比如在一个函数中，或者是在一对花括号组成的块级作用域中），作用域链上有两个对象，第一个是包含局部变量的对象（如果实在函数中，这个对象还包括了函数的参数，以及 Arguments 对象），第二个是全局对象。前者无法被 JS 代码访问到，是不可见的内部实现。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"在被嵌套的作用域中，作用域链上最少有三个对象（具体有几个对象，要看它被嵌套的层数了）。"}]}]},{type:a,value:f},{type:b,tag:R,props:{id:aC},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%BB%B6%E9%95%BF",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:aC}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"有些语句可以在作用域链的前端临时增加一个变量对象（variable object），该变量对象在代码执行完后被移除。有两种情况："}]}]},{type:a,value:f},{type:b,tag:bA,props:{},children:[{type:a,value:f},{type:b,tag:at,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"try-catch 语句中的 catch 块"}]}]},{type:a,value:f},{type:b,tag:at,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"with 语句"}]}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:ab,props:{id:aD},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#try-catch",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:aD}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"catch 语句会创建一个新的变量对象，它的值是被抛出的错误对象。在代码进入 catch 语句时，这个错误对象被添加到作用域链的顶端，当执行完 catch 语句时，该对象不再可用。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"这在 JS 中是一个特殊的情况，它不能被称之为块级作用域，比如下面这段代码："}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:M}]},{type:a,value:" e "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:bB}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:"try"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:"\n  e "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:q}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,i,J]},children:[{type:a,value:"catch"}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bD},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:"dir"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bD},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F ReferenceError: y is not defined"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F     at \u003Canonymous\u003E:3:3"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F message: \"y is not defined\""}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F stack: \"ReferenceError: y is not defined at \u003Canonymous\u003E:3:3\""}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F __proto__: Error"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"在 try 语句中引用了一个没有被声明的变量 y，它会报错，进入到 catch 语句块中，此时会在当前的作用域链顶端添加一个错误对象 e，我们可以把它输出出来，它有 message 和 stack 这两个属性。"}]},{type:a,value:f},{type:b,tag:ab,props:{id:ao},children:[{type:b,tag:D,props:{ariaHidden:C,href:"#with",tabIndex:E},children:[{type:b,tag:c,props:{className:[F,G]},children:[]}]},{type:a,value:ao}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:b,tag:t,props:{},children:[{type:a,value:"with 可将某个对象添加到作用域链的顶端，然后执行 with 语句块中的代码，执行完后会把作用域链回复到原来的状态。"}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:aO}]},{type:a,value:f},{type:b,tag:v,props:{className:[w]},children:[{type:b,tag:x,props:{className:[y,B]},children:[{type:b,tag:u,props:{},children:[{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:n}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,bp]},children:[{type:a,value:bE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:aL},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:$}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ao}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:bE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:as},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F 1, 3"}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,A,I]},children:[{type:a,value:A}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,O,n,N]},children:[{type:a,value:T}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:$},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F 2, 3"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,n]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:r}]},{type:a,value:U},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:ae}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:V}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:L}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:W}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:h}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:m,props:{},children:[{type:a,value:"在执行 f 函数的时候，里面有一条 with 语句，它会把 foo 对象添加到作用域链的顶端，在语句块中输出 x 和 y 的时候，首先它会在 foo 对象上查找有没有 x 和 y 属性，对象 Foo 正好有一个 x 属性，所以 x 的值是 1，但 foo 没有 y 属性，所以会沿着作用域链往上查找，此时查找的是参数 y，在调用 f 的时候传入的是 3，所以这里输出的 y 也是 3。执行完 with 语句后，作用域链会恢复到原来的状态，此时再输出 x 和 y 的值，它们都是调用函数 f 时传入的，所以它们的值分别是 2 和 3。因为 with 语句块中的变量只有在运行时才能确定，引擎无法提前进行优化，所以在严格模式下禁止使用 with 语句。可以换一种写法，就是用一个局部变量先把对象保存起来，再在语句块中访问这个变量的相应属性就可以了。"}]}]},dir:"\u002Farticles",path:"\u002Farticles\u002F变量作用域",extension:".md",createdAt:"2021-05-15T06:32:21.740Z",updatedAt:"2021-05-30T14:57:18.994Z"},tags:{javascript:{slug:aJ,name:aJ}},prev:{slug:bF,title:bF},next:{slug:"原型",title:"原型 Prototype"}}],fetch:[],mutations:void 0}}("text","element","span","token","punctuation","\n"," ",";","keyword","(",")","operator","p","function","number","\n  ","=","{","}","strong","code","div","nuxt-content-highlight","pre","line-numbers","comment","console","language-js","true","a",-1,"icon","icon-link",".","class-name","control-flow"," x ",",","let","property-access","method"," i ",2,"h2","var","log","x","1","3","f","2","for","alert"," y",3,"h3","return","0",":","variable","string","\u003C"," i","++","i","setTimeout","arrow","=\u003E","with","int","const","known-class-name","\n    ","li","作用域简介（scope）","作用域分类","禁止重复声明","循环语句中的块级绑定","循环语句中的函数","循环语句中的常量声明","全局块级绑定","最佳实践","作用域链延长","try-catch","10","g","em","JSON","变量作用域","javascript","value"," x","20","$x","比如下面这段代码："," y ","if"," obj "," z","作用域示例（c）：静态作用域","作用域示例（C）：静态作用域","作用域示例（perl）：动态作用域","作用域示例（Perl）：动态作用域","作用域示例（javascript）：静态作用域","作用域示例（JavaScript）：静态作用域","块级作用域（block-scope）","块级作用域（block scope）","const-声明","const 声明","暂时性死区（temporal-dead-zone-tdz）","暂时性死区（temporal dead zone, TDZ）","作用域链（scope-chain）","作用域链（scope chain）","printf","\"\\n\"","sub"," f"," g","该函数的地方查找。","boolean","\u002F\u002F Uncaught TypeError: Assignment to constant variable.","\u002F\u002F ********* 暂时性死区 **********","\u002F\u002F do something","parameter"," k ","in"," obj","obj","[","k","]","'json'","dom","window","ol","5","f_1","e","foo","原始类型和对象类型")));